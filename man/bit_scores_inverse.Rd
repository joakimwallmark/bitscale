% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bit_scores_inverse.R
\name{bit_scores_inverse}
\alias{bit_scores_inverse}
\title{Approximate Theta Scores from Bit Scores}
\usage{
bit_scores_inverse(
  model,
  bit_scores,
  items = 1:extract.mirt(model, "nitems"),
  grid_size = 10000,
  interpolation_method = c("linear", "spline"),
  extrapolation_rule = 2
)
}
\arguments{
\item{model}{An fitted unidimensional mirt model object (class 'SingleGroupClass')
from the mirt package.}

\item{bit_scores}{A numeric vector of bit scores for which the
corresponding theta scores are to be approximated.}

\item{items}{A numeric vector indicating which items were used for the
original bit score computation. Defaults to all items in the model.}

\item{grid_size}{An integer specifying the size of the theta grid used for
generating the internal lookup table. A higher value leads to improved
accuracy but increases computation time for the lookup table generation.
Default is 10000.}

\item{interpolation_method}{The method used for interpolation. Options are
"linear" (using `stats::approxfun`, default) or "spline" (using
`stats::splinefun`).}

\item{extrapolation_rule}{Applicable only when `interpolation_method` is "linear".
Specifies how extrapolation should be handled by `stats::approxfun`.
Default is `2`, which returns the theta value at the nearest data extreme.
Use `1` to return `NA` for points outside the grid range.}
}
\value{
A numeric vector of the same length as `bit_scores`, containing
  the approximated theta values. Returns `NA` for any `target_bit_scores` that
  are `NA` or fall outside the computed range if `extrapolation_rule = 1`.
}
\description{
This function approximates the original theta scores corresponding to a given
set of bit scores by inverting the relationship computed by the
`bit_scores` function using interpolation.
}
\examples{
\dontrun{
library(mirt)
# Simulate data and fit model
set.seed(123)
a <- matrix(rlnorm(30, meanlog = 0, sdlog = 0.5))
d <- matrix(rnorm(30, 0, 1))
data <- simdata(a, d, 1000, itemtype = '2PL')
mirt_model <- mirt(data, 1)

# Compute some bit scores
thetas_orig <- fscores(mirt_model, full.scores.SE = FALSE)
bit_scores_computed <- bit_scores(mirt_model, thetas_orig)
# Aproximate thetas back from bit scores
approximated_thetas <- bit_scores_inverse(
  model = mirt_model,
  bit_scores = bit_scores_computed,
  grid_size = 10000
)
# Should be only a small difference
(approximated_thetas-thetas_orig) |> abs() |> max()

# Example with spline interpolation
approximated_thetas_spline <- bit_scores_inverse(
  model = mirt_model,
  bit_scores = bit_scores_computed,
  grid_size = 10000,
  interpolation_method = "spline"
)
(approximated_thetas_spline-thetas_orig) |> abs() |> max()
}

}
