% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bit_scores.R
\name{bit_scores}
\alias{bit_scores}
\title{Convert theta scores to bit scores}
\usage{
bit_scores(
  model,
  thetas,
  items = 1:extract.mirt(model, "nitems"),
  grid_size = 10000,
  return_grid = FALSE
)
}
\arguments{
\item{model}{An fitted mirt model object from the mirt package}

\item{thetas}{A one column matrix with theta scores. Typically returned from the mirt::fscores method.}

\item{items}{A numeric vector indicating which items to use for computation. By default, all items are used.}

\item{grid_size}{An integer specifying the size of the theta grid used for bit score computation. A higher value leads to improved accuracy. Default is 10000.}

\item{return_grid}{Whether or not to return the bit score for each value in the grid used for computation or only the bit scores for the input thetas. Default is FALSE.}
}
\value{
A numeric matrix. If `return_grid` is TRUE, the matrix has two columns named "theta" and "bit_score", corresponding to the complete theta grid and the associated computed bit scores. If `return_grid` is FALSE, the matrix contains a single column of bit scores corresponding to the input theta values, preserving their original order.
}
\description{
This function takes a matrix of theta scores from a fitted IRT model and converts them to bit scores.
}
\examples{
\dontrun{
library(mirt)
# As an example, we simulate a dataset with 30 items and 1000 respondents
# discrimination parameters from a log-normal distribution
a <- matrix(rlnorm(30, meanlog = 0, sdlog = 0.5))
# difficulty parameters from a standard normal distribution
d <- matrix(rnorm(30, 0, 1))
data <- simdata(a, d, 1000, itemtype = '2PL')
# Fit the model and compute theta scores
mirt_model <- mirt(data, 1)
thetas <- fscores(mirt_model, full.scores.SE = FALSE)
# Compute the bit scores
bit <- bit_scores(mirt_model, thetas)
hist(bit, main = 'Histogram of bit scores', xlab = 'Bits')
}

}
